//
//  VirtualMachine.swift
//  Compilador
//
//  Created by Alejandro Hernández López on 03/11/21.
//

import Foundation

/**
 The virtual machine class handles the execution of the quadruples generated by the AJ compiler.
 - note: This class requires some parameters that come from the compiler as part of the execution phase. Initializing this class will assign memory for global scopes and leave the VM ready for quadruple execution.
 - parameters:
    - quadruples: Array of Quadruple that is to be executed by the mvirtual machine.
    - constants: Dictonary of constant values and its memory address.
    - symbolTable: SymbleTable for additional functions' information such as memory size or number of variables.
    - globalMemory: InfoStack structure which holds global variables information. Number of variables and total space necessary.
    - constantsInfo: InfoStack structure which holds constant variables information. Number of variables and total space necessary.
*/

class VirtualMachine {
    
    let quadruples: [Quadruple]
    var symbolTable: SymbolTable
    var activeStack: Stack<ActivationRecord> = []
    var sleepStack: Stack<ActivationRecord> = []
    var readyStack: Stack<ActivationRecord> = []
    var virtualMemory : VirtualMemory
    var startedFunc = false
    var printRes = ""
    var running : Bool = true
    var lock = DispatchSemaphore(value: 0)
    
    init(quadruples: [Quadruple], constants: [String: Int], symbolTable: SymbolTable, globalMemory : InfoStack, constantsInfo: InfoStack){
        self.quadruples = quadruples
        self.symbolTable = symbolTable
        
        let firstStack = ActivationRecord(functionSymbol: self.symbolTable.lookup("main")!)
        firstStack.index = 0
        self.activeStack.push(firstStack)
        virtualMemory = VirtualMemory(globalInfo: globalMemory, constantsInfo: constantsInfo, activeFunc : firstStack, constants: constants)
    }
    
    
    /**
        This function will start the process for reading cuadruples and processing them. It requires no additional params other than those used on the VirtualMachine initializer. It is basically a big switch that checks the quadruple operation type.
     */
    func start(){
        var currentIndex : Int = self.activeStack.peek()!.index
        guard currentIndex < self.quadruples.count else {return}
        var currentQuadruple : Quadruple
        var arg1 : Int?
        var arg2 : Int?
        var result : Int?
        var op : Operator
        // loop to iterate over all quadruples
        repeat {
            currentIndex = self.activeStack.peek()?.index ?? -1
            currentQuadruple = self.quadruples[currentIndex]
          // print("Current qua \(currentIndex)")
            arg1 = Int(currentQuadruple.argument1 ?? "0")
            arg2  = Int(currentQuadruple.argument2 ?? "0")
            result = Int(currentQuadruple.result ?? "0")
            op = currentQuadruple.op
            
            // mega switch with all valid operations and corresponding cases
            switch op {
            case .sum, .minus, .multiply, .division, .modulo, .intDivision, .greaterThan, .lessThan, .greaterOrEqualThan, .lessOrEqualThan, .equal, .different, .and, .or:
                self.basicOperation(op: op, arg1: arg1, arg2: arg2, res: result)
                self.sigQuadruple(index: currentIndexStack() + 1)
            case .assign:
               
                do{
                    var (firstValue, firstType) = try self.virtualMemory.getInfoByAddress(address: arg1!)
                    var (resValue, resType) = try self.virtualMemory.getInfoByAddress(address: result!)

                    if(resType != .pointer){
                        resValue = result
                    }
//                    
                    if(firstType == .pointer){
                        firstValue = try self.virtualMemory.getInfoByAddress(address: unwrap(firstValue) as! Int).0
                    }
                    

                    try virtualMemory.insertValue(address: Int("\(resValue!)")!, value: unwrap(firstValue))
                }catch let error{
                    print(error.localizedDescription)
                }
                self.sigQuadruple(index: currentIndexStack() + 1)
            case .goto,.gotof,.gotot:
                brincoIndex(op: op, arg1: arg1, arg2: arg2, res: result)
                break
            case .read:
                lock.wait()
                sleep(1)
                guard let line = readInput() else {
                    print("Error stdin value")
                    running = false
                    Thread().cancel()
                    return
                }

                if(line == "" || line == " "){
                    print("Error stdin value")
                    running = false
                    Thread().cancel()
                    currentIndex = 10000000
                }
                //let line = readLine() ?? ""
                let delimiter = " "
                let token = line.components(separatedBy: delimiter)
                do{
                    var (firstValue, firstType) = try self.virtualMemory.getInfoByAddress(address: result!)
                    if(firstType == .pointer){
                        let a = unwrap(firstValue) as! Int
                        try self.virtualMemory.insertValue(address: a, value: token[0])
                    }else{
                        try self.virtualMemory.insertValue(address: result!, value: token[0])
                    }
                    
                }catch let error{
                    running = false
                    Thread().cancel()
                    print(error.localizedDescription)
                }
                self.sigQuadruple(index: currentIndexStack() + 1)
                break
            case .print:
                self.printStatement(res: result ?? 0, arg1: arg1 ?? 0)
                self.sigQuadruple(index: currentIndexStack() + 1)
                break
            case .noNil:
                self.sigQuadruple(index: currentIndexStack() + 1)
                break
            case .endFunc:
                endfunc()
                break
            case .era:
                eraStatement(res: currentQuadruple.result ?? "")
                break
            case .gosub:
                self.sigQuadruple(index: currentIndexStack() + 1)
                gosubStatement()
                break
            case .param:
                parameterStatement(arg1: arg1, res: result)
                self.sigQuadruple(index: currentIndexStack() + 1)
                break
            case .rtn:
                returnStatement(arg1: arg1, res: result)
                self.sigQuadruple(index: currentIndexStack() + 1)
                break
            case .vrf:
                do{
                    let (firstValue, _) = try self.virtualMemory.getInfoByAddress(address: arg1!)
                    let (resValue, _) = try self.virtualMemory.getInfoByAddress(address: result!)
                    
                //    print("arg1 \(firstValue!) - \(firstType) res \(resValue!) - \(resType)")
                    verify(value: firstValue as! Int, in: resValue as! Int)
                }catch let error{
                    print(error.localizedDescription)
                }
                self.sigQuadruple(index: currentIndexStack() + 1)
                break
            case .sumAd:
                self.sigQuadruple(index: currentIndexStack() + 1)
                break
            }
            //self.sigQuadruple(index: currentIndexStack() + 1)
        }while(currentIndex + 1 < self.quadruples.count && running)
    }
    
    /**
        Verify function to check if a value accessing an array is between the permitted boundaries of such array.
     */
    
    func verify(value arg1: Int, in res: Int) {
        if (arg1 < 0 || arg1 >= res) {
            print("Index out of bounce \(arg1)")
            running = false
            Thread().cancel()
        }
    }
    
    /**
        Function that turns off the *running* flag in order to stop the execution of the virtual machine.
     */
    
    func stop(){
        running = false
    }
    /**
        Function that retrieves the index of the quadruple on top of the active stack.
     */
    
    func sigQuadruple(index: Int){
        self.activeStack.peek()?.index = index
    }
    
    /**
        Function to retrieve the activeStack's current index.
     */
    
    func currentIndexStack() -> Int{
        guard let indexStack = self.activeStack.peek()?.index else {return 0}
        return indexStack
    }
    
    /**
        Print function that executes the *PRINT* operation in a quadruple
     */
    
    func printStatement(res: Int, arg1: Int){
        if(res == -1){
            //print(
            print(printRes)
            printRes = ""
        }else{
            do{
                guard let value = try self.virtualMemory.getInfoByAddress(address: res).0 else {return}
                printRes += "\(value)"
            }
            catch let error{
                print(error)
            }
            if(arg1 == -2){
                printRes += ","
            }
        }
        
       
        
    }
    
    /**
        Function that executes the *ERA* operation in a quadruple
     */

    func eraStatement(res: String){
        let stack = ActivationRecord(functionSymbol: self.symbolTable.lookup(res)!)
        self.readyStack.push(stack)
        self.sigQuadruple(index: self.currentIndexStack() + 1)
    }
    
    /**
        Function that executes the *RETURN* operation in a quadruple
     */
    
    func returnStatement(arg1: Int?, res: Int?){
        guard let arg1Address = arg1 else {return}
        guard let resAddress = res else {return}
        do{
            guard let (value, _) : (Any, TypeSymbol) = try self.virtualMemory.getInfoByAddress(address: arg1Address) as? (Any, TypeSymbol) else {return}
            try self.virtualMemory.insertValue(address: resAddress, value: unwrap(value))
        } catch let error{
            running = false
            Thread().cancel()
            print(error)
        }
        
    }
    
    /**
        Function that executes the *PARAM* operation in a quadruple
     */
    
    func parameterStatement(arg1: Int?, res: Int?){
        guard let arg1Address = arg1 else {return}
        let readyActivationRecord = self.readyStack.peek()!
        do{
            guard var (value,type) : (Any, TypeSymbol) = try self.virtualMemory.getInfoByAddress(address: arg1Address) as? (Any, TypeSymbol) else {return}
            
            guard let resAddress = res else {return}
            try readyActivationRecord.saveValue(address: resAddress, val: unwrap(value))
        }catch let error{
            running = false
            Thread().cancel()
            print(error)
        }
    }
    
    /**
        Function that executes the *GOSUB* operation in a quadruple
     */
    
    func gosubStatement(){
        let readyActivationRecord = self.readyStack.pop()!
        self.activeStack.push(readyActivationRecord)
        virtualMemory.activeMemory = readyActivationRecord
    }
 
    /**
        Function that executes the *GOTO, GOTOF, GOTOT* operation in a quadruple
     */
    
    func brincoIndex(op : Operator, arg1 : Int?, arg2: Int?, res: Int?){
        guard let resultAddress = res else {return}
        if(op == .goto){
            sigQuadruple(index: resultAddress)
        }else if (op == .gotof){
            goto(compareTo: false, arg1: arg1,  res: res)
        } else if (op == .gotot){
            goto(compareTo: true, arg1: arg1, res:res)
        }
    }
    
    /**
        Function that helps on the *GOTO* operation of a quadruple
     */
    
    func goto(compareTo: Bool, arg1: Int?, res: Int?){
        do{
            guard let arg1Address = arg1 else {return}
            guard var (value,type) : (Any, TypeSymbol) = try self.virtualMemory.getInfoByAddress(address: arg1Address) as? (Bool, TypeSymbol) else {return}
            
            if(type == .pointer){
                value = try self.virtualMemory.getInfoByAddress(address: value as! Int).0
            }
            let val = value as! Bool
            if(val == compareTo){
                guard let nextQuadrupleIndex : Int = res else {return}
                sigQuadruple(index: nextQuadrupleIndex)
            }else{
                sigQuadruple(index: currentIndexStack() + 1)
            }
        }catch let error{
            running = false
            Thread().cancel()
            print(error)
        }
    }
    
    /**
        Function that executes the *ENDFUNC* operation in a quadruple
     */
    
    func endfunc(){
        self.activeStack.pop()
        guard let newActiveMemory = self.activeStack.peek() else{return}
        self.virtualMemory.activeMemory = newActiveMemory
    }
    
    /**
        This function performs basic operations between two Int variables.
     */
    
    func basicOperation(op : Operator, arg1 : Int?, arg2: Int?, res: Int?){
        
        //Operadores binarios
        do{
            var (firstValue, firstType) = try self.virtualMemory.getInfoByAddress(address: arg1!)
            if(firstType == .pointer){
                firstValue = try self.virtualMemory.getInfoByAddress(address: Int("\(firstValue!)")!).0
            }
            var (secondValue, secondType) = try self.virtualMemory.getInfoByAddress(address: arg2!)
            if(secondType == .pointer){
                secondValue = try self.virtualMemory.getInfoByAddress(address: Int("\(secondValue!)")!).0
            }
           // let typeSecond = type(of: secondValue)
//                  print(typeSecond)
            
            makeOp(op: op, first: firstValue!, second: secondValue!, res: res)

        }catch{
            
        }
       
        
    }
    
    /**
        This function performs operations, arithmetic and boolean. It handles type casting depending on the operation.
     */
    
    func makeOp(op:Operator, first: Any, second : Any, res: Int?){
        
        let boolOperators: [Operator] = [.greaterThan, .lessThan, .greaterOrEqualThan, .lessOrEqualThan, .equal, .different, .and, .or]
        let boolNumericOperators: [Operator] = [.greaterThan, .lessThan, .greaterOrEqualThan, .lessOrEqualThan, .equal, .different]
        do{
            if let firstBool = first as? Bool, let secondBool = second as? Bool, (boolOperators.contains(op)) {
                    let r = boolOp(a: firstBool, b: secondBool, op: op)
                    try? virtualMemory.insertValue(address: res! , value: r)
            }
           
            if  (boolNumericOperators.contains(op)) {
                switch first {
                case let firstInt as Int:
                    switch second {
                    case let secondInt as Int:
                        let r = boolNumericOp(a: firstInt, b: secondInt, op: op)
                        try virtualMemory.insertValue(address: res! , value: r)
                    case let secondDouble as Double:
                        let r = boolNumericOp(a: Double(firstInt), b: secondDouble, op: op)
                        try virtualMemory.insertValue(address: res! , value: r)
                    case let secondFloat as Float:
                        let r = boolNumericOp(a: Float(firstInt), b: secondFloat, op: op)
                        try virtualMemory.insertValue(address: res! , value: r)
                    default:
                        break
                    }
                case let firstDouble as Double:
                    switch second {
                    case let secondInt as Int:
                        let r = boolNumericOp(a: firstDouble, b: Double(secondInt), op: op)
                        try virtualMemory.insertValue(address: res! , value: r)
                    case let secondDouble as Double:
                        let r = boolNumericOp(a: firstDouble, b: secondDouble, op: op)
                        try virtualMemory.insertValue(address: res! , value: r)
                    case let secondFloat as Float:
                        let r = boolNumericOp(a: firstDouble, b: Double(secondFloat), op: op)
                        try virtualMemory.insertValue(address: res! , value: r)
                    default:
                        break
                    }
                case let firstFloat as Float:
                    switch second {
                    case let secondInt as Int:
                        let r = boolNumericOp(a: firstFloat, b: Float(secondInt), op: op)
                        try virtualMemory.insertValue(address: res! , value: r)
                    case let secondDouble as Double:
                        let r = boolNumericOp(a: Double(firstFloat), b: secondDouble, op: op)
                        try virtualMemory.insertValue(address: res! , value: r)
                    case let secondFloat as Float:
                        let r = boolNumericOp(a: firstFloat, b: secondFloat, op: op)
                        try virtualMemory.insertValue(address: res! , value: r)
                    default:
                        break
                    }
                default:
                    break
                }
                return
            }
            
            switch first {
            case let firstInt as Int:
                switch second {
                case let secondInt as Int:
                    let r = aritOp(a: firstInt, b: secondInt, op: op)
                    try virtualMemory.insertValue(address: res! , value: r)
                case let secondDouble as Double:
                    let r = aritOp(a: Double(firstInt), b: secondDouble, op: op)
                    try virtualMemory.insertValue(address: res! , value: r)
                case let secondFloat as Float:
                    let r = aritOp(a: Float(firstInt), b: secondFloat, op: op)
                    try virtualMemory.insertValue(address: res! , value: r)
                default:
                    break
                }
            case let firstDouble as Double:
                switch second {
                case let secondInt as Int:
                    let r = aritOp(a: firstDouble, b: Double(secondInt), op: op)
                    try virtualMemory.insertValue(address: res! , value: r)
                case let secondDouble as Double:
                    let r = aritOp(a: firstDouble, b: secondDouble, op: op)
                    try virtualMemory.insertValue(address: res! , value: r)
                case let secondFloat as Float:
                    let r = aritOp(a: firstDouble, b: Double(secondFloat), op: op)
                    try virtualMemory.insertValue(address: res! , value: r)
                default:
                    break
                }
            case let firstFloat as Float:
                switch second {
                case let secondInt as Int:
                    let r = aritOp(a: firstFloat, b: Float(secondInt), op: op)
                    try virtualMemory.insertValue(address: res! , value: r)
                case let secondDouble as Double:
                    let r = aritOp(a: Double(firstFloat), b: secondDouble, op: op)
                    try virtualMemory.insertValue(address: res! , value: r)
                case let secondFloat as Float:
                    let r = aritOp(a: firstFloat, b: secondFloat, op: op)
                    try virtualMemory.insertValue(address: res! , value: r)
                default:
                    break
                }
            default:
                break
            }
            }catch let error{
                running = false
                Thread().cancel()
                print(error.localizedDescription)
            }
        
    }
    
    func getContentAddressFromPointer(pointerAddress : Any)->Int?{
        do{
            let v = try virtualMemory.getInfoByAddress(address: Int("\(pointerAddress)")!).0
            return Int("\(v!)")
        }catch let error{
            running = false
            Thread().cancel()
            print(error.localizedDescription)
            return nil
        }
    }
    
//    func rrr(type: TypeSymbol) -> Type{
//        
//    }

//    func getRes(first: (Any?, TypeSymbol), second: (Any?, TypeSymbol), op: Operator) -> Numeric?{
//        if first.1 == .integer{
//            let a = first.0 as! Int
//        }
//    }
//
    
    /**
        Function that defines the *>* operator for cuadruple execution
     */
    
    func greaterThan<T: Arithmetic>(_ a: T, _ b: T) -> Bool {
        return a > b;
    }
    
    /**
        Function that defines the *<* operator for cuadruple execution
     */
    
    func lessThan<T: Arithmetic>(_ a: T, _ b: T) -> Bool {
        return a < b;
    }
    
    /**
        Function that defines the *>=* operator for cuadruple execution
     */
    
    
    func greaterOrEqualThan<T: Arithmetic>(_ a: T, _ b: T) -> Bool {
        return a >= b;
    }
    
    /**
        Function that defines the *<=* operator for cuadruple execution
     */
    
    
    func lessOrEqualThan<T: Arithmetic>(_ a: T, _ b: T) -> Bool {
        return a <= b;
    }
    
    /**
        Function that defines the *!=* operator for cuadruple execution.
     - note: This is for Arithemtic types
     */
    
    func different<T: Arithmetic>(_ a: T, _ b: T) -> Bool {
        return a != b;
    }
    
    /**
        Function that defines the *!=* operator for cuadruple execution.
     - note: This is for boolean types
     */
    
    func different(_ a: Bool, _ b: Bool) -> Bool {
        return a != b;
    }
    
    /**
        Function that defines the *==* operator for cuadruple execution.
      - note: This is for Arithemtic types
     */
    
    
    func equal<T: Arithmetic>(_ a: T, _ b: T) -> Bool {
        return a == b;
    }
    
    /**
        Function that defines the *==* operator for cuadruple execution
     - note: This is for boolean types
     */
    
    func equal(_ a: Bool, _ b: Bool) -> Bool {
        return a == b;
    }
    
    /**
        Function that defines the *&&* operator for cuadruple execution
     */
    
    func and(_ a: Bool, _ b: Bool) -> Bool {
        return a && b;
    }
    
    /**
        Function that defines the *||* operator for cuadruple execution
     */
    
    func or(_ a: Bool, _ b: Bool) -> Bool {
        return a || b;
    }
    
    /**
        Function that defines the *+* operator for cuadruple execution
     */
    
    func add<T: Arithmetic>(a: T, b: T) -> T {
        return a + b
    }
    
    /**
        Function that defines the *-* operator for cuadruple execution
     */
    
    func substract<T: Arithmetic>(a: T, b: T) -> T {
        return a - b
    }
    
    /**
        Function that defines the *//* operator for cuadruple execution
     */

    func division<T: Arithmetic>(a: T, b: T) -> T {
        return a / b
    }
    
    /**
        Function that defines the * operator for cuadruple execution
     */
    
    func multiply<T: Arithmetic>(a: T, b: T) -> T {
        return a * b
    }
    
    /**
        Function that defines the // operator for cuadruple execution
     */
    
    func divisionInt<T: Arithmetic>(a: T, b: T) -> T {
        return (Int("\(a / b)") ?? 0) as! T
    }
    
    /**
        Function that defines the *%* operator for cuadruple execution
     */
    
    func mod<T: Arithmetic>(a: T, b: T) -> T {
        return ((a as! Float).truncatingRemainder(dividingBy: (b as! Float))) as! T
    }
    
    /**
        Function that calls the corresponding function for all arithmetic operations for cuadruple execution.
     */
    
    func aritOp<T: Arithmetic>(a:T, b:T, op: Operator) -> T{
        switch op {
        case .sum:
            return add(a: a, b: b)
        case .minus:
            return substract(a: a, b: b)
        case .multiply:
            return multiply(a: a, b: b)
        case .division:
            return division(a: a, b: b)
        case .modulo:
            return mod(a: a, b: b)
        case .intDivision:
            return divisionInt(a: a, b: b)
        default:
            return 0 as! T
        }
    }
    
    /**
        Function that calls the corresponding function for boolean numeric operation for cuadruple execution
     */
    
    func boolNumericOp<T: Arithmetic>(a: T, b: T, op: Operator) -> Bool {
        switch op {
        case .greaterThan:
            return greaterThan(a, b)
        case .greaterOrEqualThan:
            return greaterOrEqualThan(a, b)
        case .lessThan:
            return lessThan(a, b)
        case .lessOrEqualThan:
            return lessOrEqualThan(a, b)
        case .equal:
            return equal(a, b)
        case .different:
            return different(a, b)
        default:
            return false
        }
    }
    
    /**
        Function that calls the corresponding function for boolean  operation for cuadruple execution.
     */
    
    func boolOp(a: Bool, b: Bool, op: Operator) -> Bool {
        switch op {
        case .equal:
            return equal(a, b)
        case .different:
            return different(a, b)
        case .and:
            return and(a, b)
        case .or:
            return or(a, b)
        default:
            return false
        }
    }
    
}

/**
    Definition of protocol Arithmetic which helps to overload all arithmetic operations on natively built basic data types from swift.
 */

protocol Arithmetic: Comparable {
    static func +(lhs: Self, rhs: Self) -> Self
    static func -(lhs: Self, rhs: Self) -> Self
    static func *(lhs: Self, rhs: Self) -> Self
    static func /(lhs: Self, rhs: Self) -> Self
}

/*
The following are extensions of all natively built basic data types from swift. This helps to use all functions that require a number to use arithmetic instead of a specific data type. We can think of it as an inverse abstraction.
 */

extension Int : Arithmetic {}
extension Int8 : Arithmetic {}
extension Int16 : Arithmetic {}
extension Int32 : Arithmetic {}
extension Int64 : Arithmetic {}

extension UInt8 : Arithmetic {}
extension UInt16 : Arithmetic {}
extension UInt32 : Arithmetic {}
extension UInt64 : Arithmetic {}
#if !os(iOS)
// extension Float80 : Arithmetic {}
#endif
extension Float : Arithmetic {}
extension Double : Arithmetic {}

/**
    Definition of protocol BoolP which helps to overload all boolean operations on natively built basic data types from swift.
 */

protocol BoolP {
    static func ==(_ lhs: Self, _ rhs: Self) -> Self
    static func !=(lhs: Self, rhs: Self) -> Self
}

extension Bool : BoolP {}

/**
    Function that defines the *+* operator for cuadruple execution
 */

func add<T: Arithmetic>(a: T, b: T) -> T {
    return a + b
}


func unwrap<T>(_ any: T) -> Any
{
    let mirror = Mirror(reflecting: any)
    guard mirror.displayStyle == .optional, let first = mirror.children.first else {
        return any
    }
    return first.value
}

final class LogDestination: TextOutputStream {
  private let path: String
  init() {
    let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
      let fileURL = paths.first!.appendingPathComponent("Tec").appendingPathComponent("9o semestre").appendingPathComponent("compis").appendingPathComponent("Compilador").appendingPathComponent("Compilador").appendingPathComponent("stdout.aj")
      path = fileURL.absoluteString
  }

  func write(_ string: String) {
    if let data = string.data(using: .utf8), let fileHandle = FileHandle(forWritingAtPath: path) {
      defer {
        fileHandle.closeFile()
      }
      fileHandle.seekToEndOfFile()
      fileHandle.write(data)
    }
  }
}
