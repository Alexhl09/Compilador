# NavigatorIndex

A `NavigatorIndex` contains all the necessary information to display the data inside a navigator.
The data ranges from the tree to the necessary pieces of information to filter the content and perform actions in a fast way.
A navigator index is created per bundle and needs a bundle identifier to correctly work. Anonymous bundles are allowed, but they limit
the functionalities of the index.

``` swift
public class NavigatorIndex 
```

A `NavigatorIndex` is composed by two main components:

  - A navigator tree reflecting the content curation

  - An availability index storing the information about for which platform and SDK a given symbol is available and they map USR to document's path

The two mentioned components are generated by using a `NavigatorIndex.Builder` instance, which indexes the content accordingly to the desired configuration.
A `NavigatorIndex` can be stored on disk to be later loaded. Loading an index can be performed in a single operation (synchronous) or asynchronously.
This option is extremely useful in case an application needs to load a very large amount of data while updating the UI to let the user navigate the loaded content,
while the remaining is loaded in a background thread and presented later in time.

There are few important pieces information a `NavigatorIndex` requires to properly work:

  - A bundle identifier

  - A valid LMDB database for storing availability information

  - A valid navigator tree

Building an index with one of the mentioned components is not supported.

## Initializers

### `init(url:bundleIdentifier:readNavigatorTree:presentationIdentifier:)`

Initialize an `NavigatorIndex` from a given path.

``` swift
public init(url: URL, bundleIdentifier: String? = nil, readNavigatorTree: Bool = true, presentationIdentifier: String? = nil) throws 
```

> 

#### Parameters

  - url: The URL pointing to the path from which the index should be read.
  - bundleIdentifier: The name of the bundle the index is referring to.
  - readNavigatorTree: Indicates if the init needs to read the navigator tree from the disk, if false, then `readNavigatorTree` needs to be called later. Default: `true`.
  - presentationIdentifier: Indicates if the index has an indentifier useful for presentation contexts.

#### Throws

A `NavigatorIndex.Error` describing the nature of the problem.

## Properties

### `UnknownBundleIdentifier`

A string indicating an unknown bundle identifier.

``` swift
public static let UnknownBundleIdentifier = ""
```

### `bundleKey`

The key used to store the name of the bundle inside the database.

``` swift
public static let bundleKey = "bundleIdentifier"
```

### `pathHasherKey`

The key used to store the name of path hasher inside the database.

``` swift
public static let pathHasherKey = "pathHasher"
```

### `itemsIndexKey`

The key used to store the number of indexed items.

``` swift
public static let itemsIndexKey = "itemsIndex"
```

### `url`

The url of the index.

``` swift
public let url: URL
```

### `navigatorTree`

The navigator tree.

``` swift
public let navigatorTree: NavigatorTree
```

### `availabilityIndex`

The availability index.

``` swift
public let availabilityIndex: AvailabilityIndex
```

### `bundleIdentifier`

Bundle Identifier.

``` swift
public var bundleIdentifier: String = NavigatorIndex.UnknownBundleIdentifier
```

### `presentationIdentifier`

A presentation identifier used to disambiguate content in presentation contexts.

``` swift
public let presentationIdentifier: String?
```

### `languages`

The available languages in the index.

``` swift
public lazy var languages: [String] 
```

### `languageMaskToLanguage`

The mapping from a single language mask to its interface language type.

``` swift
public lazy var languageMaskToLanguage: [UInt8: InterfaceLanguage] 
```

### `count`

The number of item indexed.

``` swift
public lazy var count: Int 
```

## Methods

### `readNavigatorTree(timeout:delay:queue:broadcast:)`

Read a tree on disk from a given path.
The read is atomically performed, which means it reads all the content of the file from the disk and process the tree from loaded data.
The queue is used to load the data for a given timeout period, after that, the queue is used to schedule another read after a given delay.
This approach ensures that the used  queue doesn't stall while loading the content from the disk keeping the used queue responsive.

``` swift
public func readNavigatorTree(timeout: TimeInterval, delay: TimeInterval = 0.01, queue: DispatchQueue, broadcast: NavigatorTree.BroadcastCallback?) throws 
```

> 

#### Parameters

  - timeout: The amount of time we can load a batch of items from data, once the timeout time pass, the reading process will reschedule asynchronously using the given queue.
  - delay: The delay to wait before schedule the next read. Default: 0.01 seconds.
  - queue: The queue to use.
  - broadcast: The callback to update get updates of the current process.

### `availabilities(for:)`

Returns an array of availabilities based on a single id.

``` swift
public func availabilities(for id: UInt64) -> [AvailabilityIndex.Info] 
```

### `path(for:language:hashed:)`

Returns the path of a given USR if existing.

``` swift
public func path(for usr: String, language: InterfaceLanguage = .swift, hashed: Bool = false) -> String? 
```

#### Parameters

  - usr: The full USR or a hashed USR.
  - language: The interface language to look the USR for.
  - hashed: A boolean indicating if the USR is hashed or not.

#### Returns

The path of a given USR, if available.

### `path(for:)`

If available, returns the path from the numeric ID inside the navigator tree.

``` swift
public func path(for id: UInt32) -> String? 
```

### `id(for:with:)`

If available, returns the ID of a path for the given language.

``` swift
public func id(for path: String, with interfaceLanguage: InterfaceLanguage) -> UInt32? 
```
